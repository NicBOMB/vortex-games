"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const turbowalk_1 = __importDefault(require("turbowalk"));
const vortex_api_1 = require("vortex-api");
const common_1 = require("./common");
const util_1 = require("./util");
const DEP_XML_LIST = 'DependedModuleMetadatas';
const DEP_XML_ELEMENT = 'DependedModuleMetadata';
class ComMetadataManager {
    constructor(api) {
        this.mApi = api;
        this.mDependencyMap = undefined;
    }
    isOptional(subModId, depId) {
        const dependency = (this.mDependencyMap[subModId]?.dependencies || []).find(dep => dep.id === depId);
        if (dependency === undefined) {
            return false;
        }
        return dependency.optional;
    }
    getDependencies(subModId) {
        return [].concat((this.mDependencyMap[subModId]?.dependencies || []).filter(dep => dep.order === 'LoadBeforeThis'), Object.keys(this.mDependencyMap).reduce((accum, iter) => {
            const subModule = this.mDependencyMap[iter];
            const deps = subModule.dependencies.filter(dep => dep.id === subModId && dep.order === 'LoadAfterThis');
            if (deps.length > 0) {
                const newDep = {
                    id: subModule.id,
                    incompatible: deps[0].incompatible,
                    optional: deps[0].optional,
                    order: 'LoadAfterThis',
                    version: (0, util_1.getCleanVersion)(subModule.id, deps[0].version),
                };
                accum = [].concat(accum, newDep);
            }
            return accum;
        }, []));
    }
    async updateDependencyMap(profileId) {
        const props = (0, util_1.genProps)(this.mApi, profileId);
        if (props === undefined) {
            this.mApi.showErrorNotification('Failed to update Dependency map', 'Game is not discovered and/or profile is invalid', { allowReport: false });
            return;
        }
        this.mDependencyMap = await this.genDependencyMap(props);
    }
    async parseSubModFile(filePath) {
        const getAttrValue = (node, attr, optional = true) => {
            try {
                const value = node?.$?.[attr];
                return Promise.resolve(value);
            }
            catch (err) {
                return optional
                    ? Promise.resolve(undefined)
                    : Promise.reject(new Error(`missing ${attr}`));
            }
        };
        let subModId;
        const dependencies = [];
        try {
            const data = await (0, util_1.getXMLData)(filePath);
            subModId = data?.Module?.Id?.[0]?.$?.value;
            const depNodes = data?.Module?.DependedModuleMetadatas?.[0]?.DependedModuleMetadata || [];
            for (const node of depNodes) {
                try {
                    const id = await getAttrValue(node, 'id', false);
                    let version = await getAttrValue(node, 'version');
                    version = (0, util_1.getCleanVersion)(id, version);
                    const dep = {
                        id,
                        optional: await getAttrValue(node, 'optional') === 'true',
                        order: await getAttrValue(node, 'order'),
                        version,
                        incompatible: await getAttrValue(node, 'incompatible') === 'true',
                    };
                    dependencies.push(dep);
                }
                catch (err) {
                    (0, vortex_api_1.log)('error', 'unable to parse community dependency', err);
                }
            }
        }
        catch (err) {
            (0, vortex_api_1.log)('error', 'failed to parse SubModule.xml', err);
            return;
        }
        return { id: subModId, dependencies };
    }
    async findSubModFiles(modPath) {
        let fileEntries = [];
        try {
            await (0, turbowalk_1.default)(modPath, entries => {
                const filtered = entries.filter(entry => !entry.isDirectory
                    && path_1.default.basename(entry.filePath).toLowerCase() === common_1.SUBMOD_FILE);
                fileEntries = fileEntries.concat(filtered);
            }).catch(err => ['ENOENT', 'ENOTFOUND'].includes(err.code)
                ? Promise.resolve()
                : Promise.reject(err));
        }
        catch (err) {
            (0, vortex_api_1.log)('error', 'unable to find submodule files', err);
            return fileEntries;
        }
        return fileEntries;
    }
    async genDependencyMap(props) {
        const { state, enabledMods } = props;
        const stagingFolder = vortex_api_1.selectors.installPathForGame(state, common_1.GAME_ID);
        const depMap = {};
        for (const modId of Object.keys(enabledMods)) {
            const mod = enabledMods[modId];
            if (mod?.installationPath === undefined) {
                continue;
            }
            const modFolder = path_1.default.join(stagingFolder, mod.installationPath);
            const subModFiles = await this.findSubModFiles(modFolder);
            for (const subModFile of subModFiles) {
                const subModData = await this.parseSubModFile(subModFile.filePath);
                if (subModData?.id !== undefined) {
                    depMap[subModData.id] = subModData;
                }
            }
        }
        return depMap;
    }
}
exports.default = ComMetadataManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29tTWV0YWRhdGFNYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiQ29tTWV0YWRhdGFNYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsZ0RBQXdCO0FBQ3hCLDBEQUE4QztBQUM5QywyQ0FBNkQ7QUFFN0QscUNBQWdEO0FBRWhELGlDQUErRDtBQUUvRCxNQUFNLFlBQVksR0FBRyx5QkFBeUIsQ0FBQztBQUMvQyxNQUFNLGVBQWUsR0FBRyx3QkFBd0IsQ0FBQztBQUlqRCxNQUFNLGtCQUFrQjtJQUd0QixZQUFZLEdBQXdCO1FBQ2xDLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO1FBQ2hCLElBQUksQ0FBQyxjQUFjLEdBQUcsU0FBUyxDQUFDO0lBQ2xDLENBQUM7SUFFTSxVQUFVLENBQUMsUUFBZ0IsRUFBRSxLQUFhO1FBQy9DLE1BQU0sVUFBVSxHQUNkLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsRUFBRSxZQUFZLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxLQUFLLENBQUMsQ0FBQztRQUNwRixJQUFJLFVBQVUsS0FBSyxTQUFTLEVBQUU7WUFDNUIsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELE9BQU8sVUFBVSxDQUFDLFFBQVEsQ0FBQztJQUM3QixDQUFDO0lBRU0sZUFBZSxDQUFDLFFBQWdCO1FBQ3JDLE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FDZCxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQUUsWUFBWSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEtBQUssZ0JBQWdCLENBQUMsRUFDakcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsS0FB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R0FBRyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDMUQsS0FBSyxNQUFNLFVBQVUsSUFBSSxXQUFXLEVBQUU7Z0JBQ3BDLE1BQU0sVUFBVSxHQUFlLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQy9FLElBQUksVUFBVSxFQUFFLEVBQUUsS0FBSyxTQUFTLEVBQUU7b0JBQ2hDLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDO2lCQUNwQzthQUNGO1NBQ0Y7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBQ0Y7QUFFRCxrQkFBZSxrQkFBa0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHR1cmJvd2FsaywgeyBJRW50cnkgfSBmcm9tICd0dXJib3dhbGsnO1xuaW1wb3J0IHsgZnMsIGxvZywgc2VsZWN0b3JzLCB0eXBlcywgdXRpbCB9IGZyb20gJ3ZvcnRleC1hcGknO1xuXG5pbXBvcnQgeyBHQU1FX0lELCBTVUJNT0RfRklMRSB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IElEZXBlbmRlbmN5LCBJUHJvcHMsIElTdWJNb2R1bGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGdlblByb3BzLCBnZXRDbGVhblZlcnNpb24sIGdldFhNTERhdGEgfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBERVBfWE1MX0xJU1QgPSAnRGVwZW5kZWRNb2R1bGVNZXRhZGF0YXMnO1xuY29uc3QgREVQX1hNTF9FTEVNRU5UID0gJ0RlcGVuZGVkTW9kdWxlTWV0YWRhdGEnO1xuXG4vLyBUaGlzIGNvbXBvbmVudCBhaW1zIHRvIGNhdGVyIGZvciB0aGUgY29tbXVuaXR5IGRldmVsb3BlZCBtZXRhZGF0YVxuLy8gIHNvcnRpbmcgbWV0aG9kb2xvZ3kuXG5jbGFzcyBDb21NZXRhZGF0YU1hbmFnZXIge1xuICBwcml2YXRlIG1BcGk6IHR5cGVzLklFeHRlbnNpb25BcGk7XG4gIHByaXZhdGUgbURlcGVuZGVuY3lNYXA6IHsgW3N1Yk1vZElkOiBzdHJpbmddOiBJU3ViTW9kdWxlIH07XG4gIGNvbnN0cnVjdG9yKGFwaTogdHlwZXMuSUV4dGVuc2lvbkFwaSkge1xuICAgIHRoaXMubUFwaSA9IGFwaTtcbiAgICB0aGlzLm1EZXBlbmRlbmN5TWFwID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHVibGljIGlzT3B0aW9uYWwoc3ViTW9kSWQ6IHN0cmluZywgZGVwSWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGRlcGVuZGVuY3k6IElEZXBlbmRlbmN5ID1cbiAgICAgICh0aGlzLm1EZXBlbmRlbmN5TWFwW3N1Yk1vZElkXT8uZGVwZW5kZW5jaWVzIHx8IFtdKS5maW5kKGRlcCA9PiBkZXAuaWQgPT09IGRlcElkKTtcbiAgICBpZiAoZGVwZW5kZW5jeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBkZXBlbmRlbmN5Lm9wdGlvbmFsO1xuICB9XG5cbiAgcHVibGljIGdldERlcGVuZGVuY2llcyhzdWJNb2RJZDogc3RyaW5nKTogSURlcGVuZGVuY3lbXSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChcbiAgICAgICh0aGlzLm1EZXBlbmRlbmN5TWFwW3N1Yk1vZElkXT8uZGVwZW5kZW5jaWVzIHx8IFtdKS5maWx0ZXIoZGVwID0+IGRlcC5vcmRlciA9PT0gJ0xvYWRCZWZvcmVUaGlzJyksXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLm1EZXBlbmRlbmN5TWFwKS5yZWR1Y2UoKGFjY3VtLCBpdGVyKSA9PiB7XG4gICAgICBjb25zdCBzdWJNb2R1bGU6IElTdWJNb2R1bGUgPSB0aGlzLm1EZXBlbmRlbmN5TWFwW2l0ZXJdO1xuICAgICAgY29uc3QgZGVwcyA9IHN1Yk1vZHVsZS5kZXBlbmRlbmNpZXMuZmlsdGVyKGRlcCA9PiBkZXAuaWQgPT09IHN1Yk1vZElkICYmIGRlcC5vcmRlciA9PT0gJ0xvYWRBZnRlclRoaXMnKTtcbiAgICAgIGlmIChkZXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbmV3RGVwOiBJRGVwZW5kZW5jeSA9IHtcbiAgICAgICAgICBpZDogc3ViTW9kdWxlLmlkLFxuICAgICAgICAgIGluY29tcGF0aWJsZTogZGVwc1swXS5pbmNvbXBhdGlibGUsXG4gICAgICAgICAgb3B0aW9uYWw6IGRlcHNbMF0ub3B0aW9uYWwsXG4gICAgICAgICAgb3JkZXI6ICdMb2FkQWZ0ZXJUaGlzJyxcbiAgICAgICAgICB2ZXJzaW9uOiBnZXRDbGVhblZlcnNpb24oc3ViTW9kdWxlLmlkLCBkZXBzWzBdLnZlcnNpb24pLFxuICAgICAgICB9O1xuICAgICAgICBhY2N1bSA9IFtdLmNvbmNhdChhY2N1bSwgbmV3RGVwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCBbXSkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHVwZGF0ZURlcGVuZGVuY3lNYXAocHJvZmlsZUlkPzogc3RyaW5nKSB7XG4gICAgY29uc3QgcHJvcHM6IElQcm9wcyA9IGdlblByb3BzKHRoaXMubUFwaSwgcHJvZmlsZUlkKTtcbiAgICBpZiAocHJvcHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5tQXBpLnNob3dFcnJvck5vdGlmaWNhdGlvbignRmFpbGVkIHRvIHVwZGF0ZSBEZXBlbmRlbmN5IG1hcCcsXG4gICAgICAgICdHYW1lIGlzIG5vdCBkaXNjb3ZlcmVkIGFuZC9vciBwcm9maWxlIGlzIGludmFsaWQnLCB7IGFsbG93UmVwb3J0OiBmYWxzZSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tRGVwZW5kZW5jeU1hcCA9IGF3YWl0IHRoaXMuZ2VuRGVwZW5kZW5jeU1hcChwcm9wcyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHBhcnNlU3ViTW9kRmlsZShmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxJU3ViTW9kdWxlPiB7XG4gICAgY29uc3QgZ2V0QXR0clZhbHVlID0gKG5vZGUsIGF0dHIsIG9wdGlvbmFsID0gdHJ1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlPy4kPy5bYXR0cl07XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25hbFxuICAgICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICA6IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgbWlzc2luZyAke2F0dHJ9YCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgc3ViTW9kSWQ7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzOiBJRGVwZW5kZW5jeVtdID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRYTUxEYXRhKGZpbGVQYXRoKTtcbiAgICAgIHN1Yk1vZElkID0gZGF0YT8uTW9kdWxlPy5JZD8uWzBdPy4kPy52YWx1ZTtcbiAgICAgIGNvbnN0IGRlcE5vZGVzID0gZGF0YT8uTW9kdWxlPy5EZXBlbmRlZE1vZHVsZU1ldGFkYXRhcz8uWzBdPy5EZXBlbmRlZE1vZHVsZU1ldGFkYXRhIHx8IFtdO1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIGRlcE5vZGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgaWQgPSBhd2FpdCBnZXRBdHRyVmFsdWUobm9kZSwgJ2lkJywgZmFsc2UpO1xuICAgICAgICAgIGxldCB2ZXJzaW9uID0gYXdhaXQgZ2V0QXR0clZhbHVlKG5vZGUsICd2ZXJzaW9uJyk7XG4gICAgICAgICAgdmVyc2lvbiA9IGdldENsZWFuVmVyc2lvbihpZCwgdmVyc2lvbik7XG4gICAgICAgICAgY29uc3QgZGVwOiBJRGVwZW5kZW5jeSA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgb3B0aW9uYWw6IGF3YWl0IGdldEF0dHJWYWx1ZShub2RlLCAnb3B0aW9uYWwnKSA9PT0gJ3RydWUnLFxuICAgICAgICAgICAgb3JkZXI6IGF3YWl0IGdldEF0dHJWYWx1ZShub2RlLCAnb3JkZXInKSxcbiAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICBpbmNvbXBhdGlibGU6IGF3YWl0IGdldEF0dHJWYWx1ZShub2RlLCAnaW5jb21wYXRpYmxlJykgPT09ICd0cnVlJyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKGRlcCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZygnZXJyb3InLCAndW5hYmxlIHRvIHBhcnNlIGNvbW11bml0eSBkZXBlbmRlbmN5JywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gV2UncmUgc2ltcGx5IGdvaW5nIHRvIGxvZyBhdCB0aGlzIHN0YWdlOyB0b28gbWFueVxuICAgICAgLy8gIG1vZHMgaGF2ZSBoYWQgaW52YWxpZCBzdWJNb2R1bGUgZmlsZXMgaW4gdGhlIHBhc3RcbiAgICAgIGxvZygnZXJyb3InLCAnZmFpbGVkIHRvIHBhcnNlIFN1Yk1vZHVsZS54bWwnLCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB7IGlkOiBzdWJNb2RJZCwgZGVwZW5kZW5jaWVzIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZpbmRTdWJNb2RGaWxlcyhtb2RQYXRoOiBzdHJpbmcpIHtcbiAgICBsZXQgZmlsZUVudHJpZXM6IElFbnRyeVtdID0gW107XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdHVyYm93YWxrKG1vZFBhdGgsIGVudHJpZXMgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IGVudHJpZXMuZmlsdGVyKGVudHJ5ID0+ICFlbnRyeS5pc0RpcmVjdG9yeVxuICAgICAgICAgICYmIHBhdGguYmFzZW5hbWUoZW50cnkuZmlsZVBhdGgpLnRvTG93ZXJDYXNlKCkgPT09IFNVQk1PRF9GSUxFKTtcbiAgICAgICAgZmlsZUVudHJpZXMgPSBmaWxlRW50cmllcy5jb25jYXQoZmlsdGVyZWQpO1xuICAgICAgfSkuY2F0Y2goZXJyID0+IFsnRU5PRU5UJywgJ0VOT1RGT1VORCddLmluY2x1ZGVzKGVyci5jb2RlKVxuICAgICAgICA/IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIDogUHJvbWlzZS5yZWplY3QoZXJyKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBUaGUgYWJpbGl0eSB0byBzb3J0IHRoZSB1c2VyJ3MgbW9kcyB1c2luZyB0aGUgY29tbXVuaXR5XG4gICAgICAvLyAgZGV2ZWxvcGVkIG1ldGFkYXRhIGlzIGEgbmljZSB0byBoYXZlIC0gYnV0IG5vdCBhIGJpZyBkZWFsIGlmXG4gICAgICAvLyAgd2UgY2FuJ3QgZG8gaXQgZm9yIHdoYXRldmVyIHJlYXNvbi5cbiAgICAgIGxvZygnZXJyb3InLCAndW5hYmxlIHRvIGZpbmQgc3VibW9kdWxlIGZpbGVzJywgZXJyKTtcbiAgICAgIHJldHVybiBmaWxlRW50cmllcztcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsZUVudHJpZXM7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdlbkRlcGVuZGVuY3lNYXAocHJvcHM6IElQcm9wcyk6IFByb21pc2U8eyBbc3ViTW9kSWQ6IHN0cmluZ106IElTdWJNb2R1bGU7IH0+IHtcbiAgICBjb25zdCB7IHN0YXRlLCBlbmFibGVkTW9kcyB9ID0gcHJvcHM7XG4gICAgY29uc3Qgc3RhZ2luZ0ZvbGRlciA9IHNlbGVjdG9ycy5pbnN0YWxsUGF0aEZvckdhbWUoc3RhdGUsIEdBTUVfSUQpO1xuICAgIGNvbnN0IGRlcE1hcDogeyBbc3ViTW9kSWQ6IHN0cmluZ106IElTdWJNb2R1bGUgfSA9IHt9O1xuICAgIGZvciAoY29uc3QgbW9kSWQgb2YgT2JqZWN0LmtleXMoZW5hYmxlZE1vZHMpKSB7XG4gICAgICBjb25zdCBtb2QgPSBlbmFibGVkTW9kc1ttb2RJZF07XG4gICAgICBpZiAobW9kPy5pbnN0YWxsYXRpb25QYXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1vZEZvbGRlciA9IHBhdGguam9pbihzdGFnaW5nRm9sZGVyLCBtb2QuaW5zdGFsbGF0aW9uUGF0aCk7XG4gICAgICBjb25zdCBzdWJNb2RGaWxlcyA9IGF3YWl0IHRoaXMuZmluZFN1Yk1vZEZpbGVzKG1vZEZvbGRlcik7XG4gICAgICBmb3IgKGNvbnN0IHN1Yk1vZEZpbGUgb2Ygc3ViTW9kRmlsZXMpIHtcbiAgICAgICAgY29uc3Qgc3ViTW9kRGF0YTogSVN1Yk1vZHVsZSA9IGF3YWl0IHRoaXMucGFyc2VTdWJNb2RGaWxlKHN1Yk1vZEZpbGUuZmlsZVBhdGgpO1xuICAgICAgICBpZiAoc3ViTW9kRGF0YT8uaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlcE1hcFtzdWJNb2REYXRhLmlkXSA9IHN1Yk1vZERhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVwTWFwO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbU1ldGFkYXRhTWFuYWdlcjtcbiJdfQ==